# HG changeset patch
# Parent 3c764487f56cec89a0e6a4d2b8326c33d1fd5a4e
Bug 897735 - Support regular expression filters for name and creator in extension blocks

diff --git a/toolkit/mozapps/extensions/nsBlocklistService.js b/toolkit/mozapps/extensions/nsBlocklistService.js
--- a/toolkit/mozapps/extensions/nsBlocklistService.js
+++ b/toolkit/mozapps/extensions/nsBlocklistService.js
@@ -44,16 +44,19 @@
 const DEFAULT_SEVERITY                = 3;
 const DEFAULT_LEVEL                   = 2;
 const MAX_BLOCK_LEVEL                 = 3;
 const SEVERITY_OUTDATED               = 0;
 const VULNERABILITYSTATUS_NONE             = 0;
 const VULNERABILITYSTATUS_UPDATE_AVAILABLE = 1;
 const VULNERABILITYSTATUS_NO_UPDATE        = 2;
 
+// A list of filters an extension can be blocked with.
+const EXTENSION_BLOCK_FILTERS = ["id", "name", "creator", "updateURL", "homepageURL"];
+
 var gLoggingEnabled = null;
 var gBlocklistEnabled = true;
 var gBlocklistLevel = DEFAULT_LEVEL;
 
 XPCOMUtils.defineLazyServiceGetter(this, "gConsole",
                                    "@mozilla.org/consoleservice;1",
                                    "nsIConsoleService");
 
@@ -266,16 +269,24 @@
 function Blocklist() {
   let os = getObserverService();
   os.addObserver(this, "xpcom-shutdown", false);
   gLoggingEnabled = getPref("getBoolPref", PREF_EM_LOGGING_ENABLED, false);
   gBlocklistEnabled = getPref("getBoolPref", PREF_BLOCKLIST_ENABLED, true);
   gBlocklistLevel = Math.min(getPref("getIntPref", PREF_BLOCKLIST_LEVEL, DEFAULT_LEVEL),
                                      MAX_BLOCK_LEVEL);
   gPref.addObserver("extensions.blocklist.", this, false);
+  this._addonCache = {};
+  let self = this;
+  let types = ["extension", "theme", "locale", "dictionary", "service"];
+  AddonManager.getAddonsByTypes(types, function(addons) {
+    for (let addon of addons) {
+      self._addonCache[addon.id] = addon;
+    }
+  });
 }
 
 Blocklist.prototype = {
   /**
    * Extension ID -> array of Version Ranges
    * Each value in the version range array is a JS Object that has the
    * following properties:
    *   "minVersion"  The minimum version in a version range (default = 0)
@@ -368,21 +379,55 @@
         return currentblItem.severity >= gBlocklistLevel ? Ci.nsIBlocklistService.STATE_BLOCKED :
                                                        Ci.nsIBlocklistService.STATE_SOFTBLOCKED;
     }
     return Ci.nsIBlocklistService.STATE_NOT_BLOCKED;
   },
 
   _findMatchingAddonEntry: function Blocklist_findMatchingAddonEntry(aAddonEntries,
                                                                      aId) {
+    // Returns true if the params object passes the constraints set by entry.
+    // (For every non-null property in entry, the corresponding property in params
+    // must exist and be the same)
+    function checkEntry(entry, params) {
+      for (let key in entry) {
+        if (entry[key] === null || entry[key] === undefined)
+          continue;
+        if (params[key]) {
+          if (entry[key] instanceof RegExp) {
+            if (!entry[key].test(params[key])) {
+              return false;
+            }
+          } else if (entry[key] !== params[key]) {
+            return false;
+          }
+        } else {
+          return false;
+        }
+      }
+      return true;
+    }
+
+    let params = {
+      id: aId
+    };
+
+    let addon = this._addonCache[aId];
+    if (addon) {
+      for (let filter of EXTENSION_BLOCK_FILTERS) {
+        if (addon[filter]) {
+          params[filter] = addon[filter];
+        }
+      }
+    }
+    if (params.creator)
+      params.creator = params.creator.name;
+
     for (let entry of aAddonEntries) {
-      if (entry.id instanceof RegExp) {
-        if (entry.id.test(aId))
-          return entry;
-      } else if (entry.id == aId) {
+      if (checkEntry(entry.attributes, params)) {
         return entry;
       }
     }
     return null;
   },
 
   /* See nsIBlocklistService */
   getAddonBlocklistURL: function Blocklist_getAddonBlocklistURL(id, version, appVersion, toolkitVersion) {
@@ -714,28 +759,36 @@
     return result;
   },
 
   _handleEmItemNode: function Blocklist_handleEmItemNode(blocklistElement, result) {
     if (!matchesOSABI(blocklistElement))
       return;
 
     let blockEntry = {
-      id: null,
       versions: [],
-      blockID: null
+      blockID: null,
+      attributes: {}
+      // Atleast one of these must get added to attributes:
+      // id, creator, name, updateURL, homepageURL
     };
 
+    // Add-on attributes don't start with '/', so any of those
+    // starting with '/' must be a regex.
+    function RegExpCheck(attr) {
+      return attr.startsWith("/") ? parseRegExp(attr) : attr;
+    }
+
+    for (let filter of EXTENSION_BLOCK_FILTERS) {
+      let attr = blocklistElement.getAttribute(filter);
+      if (attr)
+        blockEntry.attributes[filter] = RegExpCheck(attr);
+    }
+
     var versionNodes = blocklistElement.childNodes;
-    var id = blocklistElement.getAttribute("id");
-    // Add-on IDs cannot contain '/', so an ID starting with '/' must be a regex
-    if (id.startsWith("/"))
-      id = parseRegExp(id);
-    blockEntry.id = id;
-
     for (var x = 0; x < versionNodes.length; ++x) {
       var versionRangeElement = versionNodes.item(x);
       if (!(versionRangeElement instanceof Ci.nsIDOMElement) ||
           versionRangeElement.localName != "versionRange")
         continue;
 
       blockEntry.versions.push(new BlocklistItemData(versionRangeElement));
     }
@@ -891,16 +944,18 @@
   _blocklistUpdated: function Blocklist_blocklistUpdated(oldAddonEntries, oldPluginEntries) {
     var addonList = [];
 
     var self = this;
     const types = ["extension", "theme", "locale", "dictionary", "service"]
     AddonManager.getAddonsByTypes(types, function blocklistUpdated_getAddonsByTypes(addons) {
 
       for (let addon of addons) {
+        if (!self._addonCache[addon.id])
+          self._addonCache[addon.id] = addon;
         let oldState = Ci.nsIBlocklistService.STATE_NOTBLOCKED;
         if (oldAddonEntries)
           oldState = self._getAddonBlocklistState(addon.id, addon.version,
                                                   oldAddonEntries);
         let state = self.getAddonBlocklistState(addon.id, addon.version);
 
         LOG("Blocklist state for " + addon.id + " changed from " +
             oldState + " to " + state);
